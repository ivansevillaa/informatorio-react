# Clases y Prototipos

Tengamos en cuenta este ejemplo donde nos encontramos creando objetos con la misma estructura de m茅todos y propiedades

```js
const user1 = {
  name: 'Ivan',
  score: 3,
  addPoints: (points) => {
    if(typeof points === 'number' && points > 0) {
      this.score = this.score + points
    }
  }
}

const user2 = {
  name: 'Pepe',
  score: 5,
  addPoints: (points) => {
    if(typeof points === 'number' && points > 0) {
      this.score = this.score + points
    }
  }
}

const user3 = {
  name: 'Camila',
  score: 12,
  addPoints: (points) => {
    if(typeof points === 'number' && points > 0) {
      this.score = this.score + points
    }
  }
}
```

Para ello podemos crear moldes o templates para posteriormente utilizarlo para crear estos objetos. Estos moldes o templates se conocen como clases, aunque en JavaScript con lo que en realidad tenemos son `prototipos`, no clases   

Pero entonce... si no tenemos clases, c贸mo creo estos moldes para posteriormente instanciar los objetos?

## Soluci贸n 1 - Instanciar objetos a trav茅s de funciones

```js
function userCreator(name, points) {
  const user = {}
  user.name = name
  user.points = points
  user.addPoints = function(points) {
    if(typeof points === 'number' && points > 0) {
      user.points = user.points + points
    }
  }
  return user
}

const user1 = userCreator('Ivan', 10)
console.log(user1.name)
console.log(user1.points)
user1.addPoints(8)
console.log(user1.points)
```

Pero esta soluci贸n, es del todo efectiva?  Bueno, tiene la ventaja de que es intuitivo y sencillo entender que est谩 sucediendo en el c贸digo. Pero, tiene la gran desventaja de que cada vez que ejecutemos nuestra funci贸n `userCreator` estamos ocupando espacio en memoria con las propiedades y funciones que tengamos. Por m谩s que la funci贸n sea identica para todos nuestros objetos, estamos creando una copia y ocupando espacio con literalmente las mismas l铆neas de c贸digo. Si creamos 100000 usuarios, vamos a crear y guardar 100000 veces la misma funci贸n. Es ah铆 donde tenemos espacio para mejorar.

## Soluci贸n 2 - Usar la cadena de prototipos

```js
function userCreator(name, points) {
  const user = Object.create(userFunctions)
  user.name = name
  user.points = points
  return user
}

const userFunctions = {
  addPoints: function(points) {
    if(typeof points === 'number' && points > 0) {
      this.points = this.points + points
    }
  }
}

const user1 = userCreator('Ivan', 10)
console.log(user1.name)
console.log(user1.points)
user1.addPoints(8)
console.log(user1.points)
```

Esto tiene problemas?  La respuesta es no, no tiene problemas. Pero no es estandar en el mundo de la programaci贸n orientada a objetos. En JavaScript tenemos la posibilidad de hacerlo de "la forma estandar". Pero es importante tener en cuenta que por debajo funciona con la cadena de prototipos. Por lo tanto es muy importante que entiendas como funciona realmente. Es por ello que mencionaba que en JavaScript lo que en realidad tenemos son `prototipos` y no clases


## Soluci贸n 3 - new

`new` nos va a automatizar el trabajo de  crear un nuevo objeto, el cual al final lo va a retornar. Ese objeto ser谩 `this`, es el binding que nos falt贸 ver la clase pasada `new binding`

Y pero que pasa con los m茅todos? Bueno, debemos agregarlo a la propiedad protoype de nuestra funci贸n `userCreator`. Si.... las funciones pueden tener propiedades..., y una que tiene por defecto es prototype, la cual inicialmente es un objeto vac铆o.

```js
function userCreator(name, points) {
  this.name = name;
  this.points = points;
}

userCreator.prototype.addPoints = function (points) {
  if (typeof points === 'number' && points > 0) {
    this.points = this.points + points;
  }
};

const user1 = new userCreator('Ivan', 10);
console.log(user1);
console.log(user1.name);
console.log(user1.points);
user1.addPoints(8);
console.log(user1.points);
```

## Soluci贸n 4 - class

En ES6, se agreg贸 la posibilidad de crear clases en el lenguaje. Pero recuerden que por debajo sigue funcionando con prototipos. Es decir por m谩s que usemos las clases, JavaScript se sigue comportando como lo explicamos en la soluci贸n 3. A esto se lo conoce como 'syntactic sugar'.

Actualmente, en la soluci贸n 3, tenemos separado la definici贸n de nuestros m茅todos de nuestro constructor de objetos. Otros lenguajes nos permiten tener todo junto. Que es lo que nos otorg贸 JavaScript con ES6 

```js
class User {
  constructor(name, points) {
    this.name = name;
    this.points = points;
  }

  addPoints = function (points) {
    if (typeof points === 'number' && points > 0) {
      this.points = this.points + points;
    }
  };
}

const user1 = new User('Ivan', 10);
console.log(user1);
console.log(user1.name);
console.log(user1.points);
user1.addPoints(8);
console.log(user1.points);
```


Links 煤tiles:
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
