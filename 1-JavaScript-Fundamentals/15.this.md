# this keyword

Para repasar... como vimos en el archivo anterior, por `contexto` nos referimos al valor que tiene la palabra reservada `this` en el moment贸 de la ejecuci贸n. `this` hace referencia al objeto que est谩 ejecutando una funci贸n.

```js
// Que imprime esto?
function eatFruit(fruit) {
  console.log(`Voy a comer una ${fruit}`)
}


// Y esto???
function eatFruit() {
  console.log(`Voy a comer una ${this.fruitName}`)
}

// Y ahora??
const fruit = {
  fruitName: 'Manzana',
  price: 999,
  eat: function() {
    console.log(`Voy a comer una ${this.fruitName}`)
  }
}
```

癸 Para entender que valor tiene `this`, es importante entender quien est谩 ejecutando la funci贸n. O dicho de forma m谩s t茅cnica, como dijimos anteriormente, en que contexto se est谩 ejecutando la funci贸n en un momento espec铆fico. Y acordate de no confundirlo con contexto de ejecuci贸n que vimos anteriormente.

```js
const fruit = {
  fruitName: 'Manzana',
  price: 999,
  eat: function() {
    console.log(`Voy a comer una ${this.fruitName}`)
  }
}

fruit.eat()

// Pero que pasa si guardo el m茅todo en una varible? Algo similar sucede cuando queremos trabajar con eventos del navegador

const eat = fruit.eat
eat()
```

Como se ve existen casos donde necesitamos hacer un binding explicito. Binding no es mas que asignar que valor va a tener `this` al momento de ejecutar la funci贸n

## Tipos de Bindings

Es importante tener en cuenta que el orden en que JavaScript aplica el tipo de binding es tal cual se detalla abajo

### Lexical binding (Arrow functions)
Ocurre al escribir arrow functions. `this` dentro de la arrow function va a valer, lo mismo que vale al momento de ser asignada
```js
const fruit = {
  fruitName: 'Manzana',
  price: 999,
  eat: function() {
    const obtenerPrecio = () => {
      console.log(`Precio: ${this.price}`)
    }
    console.log(`Voy a comer una ${this.fruitName}`) // el valor de this es el objeto que ejecuta la funci贸n
    obtenerPrecio()
  }
}

fruit.eat()
```

### New binding (Instanciar objetos)
Este te prometo que lo vemos la clase que viene. Antes debemos explicar prototipos y clases!! 

### Explicit binding (Invocacion indirecta)
Nos sirve para establecer de forma explicita que valor queremos que tome `this` en el momento de ejecutar la funci贸n. Esto lo hacemos a trav茅s de m茅todos que todas las funciones traen

El m茅todo call nos permite invocar la funci贸n cambiando su contexto. El nuevo contexto se lo pasaremos por parametro
```js
const apple = {
  fruitName: 'Manzana',
  price: 999,
  eat: function() {
    console.log(`Voy a comer una ${this.fruitName}`) // el valor de this es el objeto le pasamos al m茅todo call
  }
}

const banana = {
  fruitName: 'Banana'
}

apple.eat.call(banana)
```

El m茅todo bind nos retorna una nueva funci贸n con el contexto que le pasemos por parametro
```js
const fruit = {
  fruitName: 'Manzana',
  price: 999,
  eat: function() {
    console.log(`Voy a comer una ${this.fruitName}`)
  }
}

const eat = fruit.eat.bind(fruit)
eat()
```

### Implicit binding (Invocacion de metodo)
Ocurre al invocar el metodo de un objeto
```js
const fruit = {
  fruitName: 'Manzana',
  price: 999,
  eat: function() {
    console.log(`Voy a comer una ${this.fruitName}`) // el valor de this es el objeto que ejecuta la funci贸n
  }
}

fruit.eat()
```

```js
const fruit = {
  fruitName: 'Manzana',
  price: 999,
  eat: function() {
    function obtenerPrecio() {
      console.log(`Precio: ${this.price}`)
    }
    console.log(`Voy a comer una ${this.fruitName}`) // el valor de this es el objeto que ejecuta la funci贸n
    obtenerPrecio()
  }
}

fruit.eat()
```

### Default binding (Invocacion directa)
```js
function queTieneThis() {
  console.log(this) // objeto global (en los navegadores se llama window), o undefined. depende la version de js que est茅n usando 
}

queTieneThis()
```

Ejercicio:

Crea una funci贸n `imprimirNombre` que tome un objeto con una propiedad `nombre` y un m茅todo `saludar`. El m茅todo `saludar` debe imprimir en la consola "Hola, soy X" utilizando `this`. La funci贸n `imprimirNombre` debe llamar al m茅todo `saludar` del objeto que recibe como argumento. Luego, llama a la funci贸n `imprimirNombre` pas谩ndole un objeto con una propiedad `nombre`.

Solucion:

```js
const persona = {
  saludar: function() {
    console.log(`Hola, soy ${this.nombre}`)
  }
}

const ivan = {
  nombre: 'Ivan'
}

function imprimirNombre(obj) {
  if (obj.hasOwnProperty('nombre')) { // Validamos que 'obj' tenga la propiedad 'nombre'
    persona.saludar.call(obj)
    const saludar = persona.saludar.bind(obj)
    saludar()
  } else {
    console.log('El objeto no tiene la propiedad "nombre"')
  }
}

imprimirNombre(ivan)
```


Links 煤tiles:
  - https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/this
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind
